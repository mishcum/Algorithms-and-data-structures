# Введение.
## [A. A + B](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/A.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Выведите сумму двух чисел.

### Формат ввода

На вход подается 2 целых числа: `a` и `b` (-10<sup>9</sup> ≤ `a`, `b` ≤ 10<sup>9</sup>).

### Формат вывода

Необходимо вывести 1 число: `a + b`

### Пример 1

**Ввод:**
2 3

**Вывод:**
5
### Пример 2

**Ввод:**
17 -18

**Вывод:**
-1

## [B. Числа Фибоначчи](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/B.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В этой задаче Вам необходимо написать решение, позволяющее найти `n` - ое число Фибоначчи. Напомню, что числа Фибоначчи вычисляются следующим образом: $fib_n = fib_{n-1} + fib_{n-2}$,  при условии, что $fib_1 = 1, fib_2 = 1$.

### Формат ввода

На вход подается 1 целое число `n` (`1` < `n` < `80`)

### Формат вывода

Выведите значение `n` − ого числа Фибоначчи.

### Пример 1

**Ввод:**
1

**Вывод:**
1
### Пример 2

**Ввод:**
2

**Вывод:**
1
### Пример 3

**Ввод:**
3

**Вывод:**
2
### Пример 4

**Ввод:**
4

**Вывод:**
3

## [C. Проверка на простоту](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/C.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Проверьте, является ли число простым.

### Формат ввода

Вводится одно натуральное число `n`, не превышающее $2 \times 10^9$ и не равное 1.

### Формат вывода

Необходимо вывести строку `prime`, если число простое, или `composite`, если число составное.

### Пример

**Ввод:**
2

**Вывод:**
prime

## [D. Успеваемость](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/D.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Проверьте, является ли число простым.

### Формат ввода

Вводится одно натуральное число `n`, не превышающее $2 \times 10^9$ и не равное 1.

### Формат вывода

Необходимо вывести строку `prime`, если число простое, или `composite`, если число составное.

### Пример

**Ввод:**
2

**Вывод:**
prime

## [E. Разложение на простые](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/E.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Требуется разложить целое число `N` на простые множители и вывести результат в порядке возрастания.

### Формат ввода

Программе дано число `N` $(2 ≤ N ≤ 10^9)$.

### Формат вывода

Вывести разложение `N` на простые множители.

### Пример 1

**Ввод:**
2

**Вывод:**
2
### Пример 2

**Ввод:**
1008

**Вывод:**
2^4 * 3^2*7

## [F. К-е простое число](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/F.java)
| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

По введенному натуральному числу k, не превосходящему 100 000, выдать k-е по счету простое число. Используйте массив для запоминания уже найденных простых чисел.

### Пример

**Ввод:**
2

**Вывод:**
3

## [G. Разделим все!](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Introduction/G.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Перед Вами расположены $n$ чисел. В этой задачке Вам необходимо найти такое целое число $k$, что на него делятся все представленные $n$ чисел. При этом $k$ должно быть максимально возможным. Например, пусть все числа делятся на $1$, $2$, $7$, $12$. Тогда ответом на задачу будет число $12$.

### Формат ввода

В первой строке дано целое число $n$ $(1≤n≤1000)$.  
Во второй строке даны $n$ целых чисел через пробел $(1 ≤ n_i ≤ 10^9)$.

### Формат вывода

Выведите искомое число.

### Пример 1

**Ввод:**  
1  
3

**Вывод:**  
3
### Пример 2

**Ввод:**  
4  
4 10 5 2

**Вывод:**  
1

# Квадратичные сортировки.

## [A. Сортировка пузырьком](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/A.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Вам необходимо реализовать **сортировку пузырьком по неубыванию** и посчитать количество обменов, совершённых при сортировке.

### Формат ввода

В первой строке - одно целое число $n$ – количество чисел, которые надо отсортировать. Во второй строке записано $n$ целых неотрицательных чисел, не превышающих $10^9$.  
Гарантируется, что $0 ≤ n ≤ 10^4$.
### Формат вывода

Сначала выведите отсортированный массив через пробел, а затем в новой строке одно число – количество обменов, совершённых при сортировке массива.

### Пример 1

**Ввод:**  
3  
1 2 3

**Вывод:**  
1 2 3  
0
### Пример 2

**Ввод:**  
4   
2 1 4 3

**Вывод:**  
1 2 3 4  
2

## [B. Сортировка простыми вставками](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/B.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Вам необходимо реализовать **сортировку простыми вставками по неубыванию** и посчитать количество элементов, которые при добавлении к сортированной части уже находились на своём месте, то есть которые не пришлось двигать.

### Формат ввода

В первой строке - одно целое число $n$ – количество чисел, которые надо отсортировать. Во второй строке записано $n$ целых неотрицательных чисел, не превышающих $10^9$.  
Гарантируется, что $0 ≤ n ≤ 10^4$.
### Формат вывода

Сначала выведите отсортированный массив через пробел, а затем в новой строке одно число – количество обменов, совершённых при сортировке массива.

### Пример 1

**Ввод:**  
5    
1 2 5 3 4

**Вывод:**  
1 2 3 4 5  
2
### Пример 2

**Ввод:**  
5   
1 2 3 4 5

**Вывод:**  
1 2 3 4 5    
4

## Примечания
Пояснение к примеру 1:
Изначально отсортированная часть состоит из одного элемента.  
Шаг 1. Число 2 находится на своём месте, добавляем 1 к ответу. **1 2** 5 3 4  
Шаг 2. Число 5 находится на своём месте, добавляем 1 к ответу. **1 2 5** 3 4  
Шаг 3. Число 3 не находится на своём месте, сдвигаем его. **1 2 3 5** 4  
Шаг 4. Число 5 не находится на своём месте, сдвигаем его. **1 2 3 4 5**  
**Массив отсортирован, ответ 2.**  
Пояснение к примеру 2:
Изначально отсортированная часть состоит из одного элемента, остальные четыре элемента уже находятся на своём месте, поэтому ответ 4.

## [C. Метод Вставками](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/C.java)

| Ограничение времени | 1.5 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Вы — специалист по обработке данных, перед которым стоит задача оптимизации своего массива чисел. Вы решили применить метод сортировки вставками, чтобы расположить свою коллекцию в порядке возрастания. Особенность вашей методики заключается в тщательном анализе каждого шага: вы выводите преобразования своего массива после каждого этапа внедрения элемента на новое место. Если массив изначально упорядочен, вы не предпринимаете никаких действий.

### Формат ввода

Ввод начинается с числа, указывающего на количество элементов в вашей коллекции $(1 ≤ n ≤ 1000)$. В строке, следующей за ним, располагается сама коллекция — последовательность натуральных чисел $(1 ≤ a_{i} ≤ 10^9)$
### Формат вывода

Вам требуется сделать записи, отображающие конфигурацию массива после каждого этапа сортировки вставками. Общее количество представленных строк должно соответствовать количеству выполненных операций вставки.

### Пример 1

**Ввод:**  
4  
84 74 98 7

**Вывод:**  
74 84 98 7  
7 74 84 98

### Пример 2

**Ввод:**  
7   
72 20 76 80 90 37 88

**Вывод:**  
20 72 76 80 90 37 88  
20 37 72 76 80 90 88  
20 37 72 76 80 88 90  

### Пример 3

**Ввод:**  
2  
82 17

**Вывод:**  
17 82

## [D. Результаты соревнований](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/D.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Во время проведения соревнования каждый из спортсменов получил свой идентификационный номер – натуральное число. Необходимо отсортировать список спортсменов соревнования по количеству набранных ими очков.

### Формат ввода

На первой строке дано число $n$ $(1≤n≤1000)$ – количество спортсменов. На каждой следующей строке даны идентификационный номер и набранное число очков соответствующего спортсмена. Все числа во входном файле не превышают $10^5$.

### Формат вывода

В выходной файл выведите исходный список в порядке убывания очков. Если у некоторых спортсменов одинаковые очки, то их между собой нужно упорядочить в порядке возрастания идентификационного номера.

### Пример 1

**Ввод:**  
3  
101 75  
301 85  
201 25  

**Вывод:**  
301 85  
101 75  
201 25  

### Пример 2

**Ввод:**  
3  
10 70  
30 80  
20 80  


**Вывод:**  
20 80  
30 80  
10 70   

## [E. Хипуй!](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/E.java)

| Ограничение времени | 4 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:  
1) $Insert(k)$ – добавить в Heap число $k$ $(1≤k≤1000000)$.  
2) $Extract$ - достать из Heap наибольшее число (удалив его при этом).

### Формат ввода

В первой строке содержится количество команд $N$ $(1≤N≤100000)$, далее следуют $N$ команд, каждая в своей строке. Команда может иметь формат: “0 <число>” или “1”, обозначающий, соответственно, операции Insert(<число>) и Extract. Гарантируется, что при выполенении команды Extract в структуре находится по крайней мере один элемент.

### Формат вывода

Для каждой команды извлечения необходимо отдельной строкой вывести число, полученное при выполнении команды Extract.

### Пример 

**Ввод:**  
2  
0 10000  
1    

**Вывод:**  
10000

## [F. Пирамидальная сортировка](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/F.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Отсортируйте данный массив. Используйте пирамидальную сортировку.

### Формат ввода

Первая строка входных данных содержит количество элементов в массиве $N$ $N ≤ 10^5$.  
Далее задаются $N$ целых чисел, не превосходящих по абсолютной величине $10^9$.

### Формат вывода

Выведите эти числа в порядке неубывания.

### Пример 

**Ввод:**  
5  
5 4 3 2 1   

**Вывод:**  
1 2 3 4 5 

## [G. Склад](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/G.java)

| Ограничение времени | 1 секундa       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Лаборатория хранит на складе контейнеры с опасными веществами. Сам склад разделен на N*M отсеков, притом в каждом отсеке может храниться только 1 контейнер. Каждый контейнер имеет свою массу, каждый отсек может вместить контейнер не больше какой-то массы. Если окажется, что на склад поставили контейнер с большей массой, чем соответствующий отсек может выдержать, случится взрыв.  
Завхоз придумывает расстановку контейнеров. Необходимо определить, какое количество контейнеров удастся разместить на складе так, чтобы не случился взрыв.

### Формат ввода

В первой строке даны числа $N$ и $M$ $(1 ≤ N, M ≤ 100)$. В каждой из последующих $N$ строк содержится по $M$ чисел, каждое из которых обозначает, какой вес контейнера может выдержать соответствующий отсек склада. В (N+2)-ой строке находится число $K$ $(1 ≤ K ≤ 2000)$ – количество контейнеров с химикатами. В (N+3)-ей строке содержатся K чисел, i-ое из которых – масса i-ого контейнера. Масса любого контейнера не превышает $2^{32}$.

### Формат вывода

Требуется вывести одно число – максимально возможное количество контейнеров на складе.  

### Пример 1 

**Ввод:**  
3 3  
6 55 52  
33 45 31  
4 52 55  
6  
101 27 20 51 59 95   

**Вывод:**  
3

### Пример 2 

**Ввод:**  
3 3  
51 26 15  
14 53 30  
60 59 46  
6  
95 54 72 28 11 58   

**Вывод:**  
4

### Пример 3 

**Ввод:**  
3 3  
30 34 29  
56 2 16  
37 28 18  
6  
72 70 10 13 7 91    

**Вывод:**  
3

## [H. Агентство по подбору персонала](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting/H.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Биба и Боба работают в HR агентстве, они хотят быстро научиться определять на какие проекты лучше назначать каких людей.  

Биба и Боба решают смоделировать эту задачу с помощью двух массивов $arr1$ и $arr2$, каждый из которых содержит $n$ положительных целых чисел. Эти числа представляют веса, которые работники $(arr1)$ и проекты $(arr2)$ имеют друг для друга.  
Например, если $arr1_{0} = 5$ и $arr2_{0} = 3$, то это означает, что первый работник предпочитает первое задание на 5 баллов, а первый проект подходит первому работнику на 3 балла.  
Оптимальное соответствие между работниками и проектами будет таким, при котором сумма квадратов разности между $arr1$ и $arr2$ будет минимальной.  
$∑^{n}_{i=1}(arr1[i]−arr2[i])^2 → min$  
Однако, Биба и Боба знают, что иногда веса расставлены неверно (но не критично для фирмы), поэтому они могут изменить любой элемент $arr1$ на $+1$ или $-1$ не более $a$ раз, и аналогично для $arr2$ не более $b$ раз.  

Биба и Боба хотят написать программу, которая принимает на вход массивы 
$arr1$ и $arr2$, и возвращает минимальную сумму квадратов разности после изменения массивов не более $a$ и $b$ раз соответственно.

### Формат ввода

В первой строке дано число $n$ $(1≤n≤10^6)$ - длина массивов  
Во второй и третьей строках даны $n$ чисел первого и второго массивов  
$(1≤arr1[i],arr2[i]≤10^5)$  
В четвертой и пятой строках даны числа $a$ и $b$ $(0≤a,b≤10^7)$

### Формат вывода

Выведите искомое число - минимальную сумму квадратов разностей массивов  

### Пример 1 

**Ввод:**    
1  
31497  
39940  
45  
49  

**Вывод:**   
69705801 

### Пример 2 

**Ввод:**  
1  
44691  
58207  
18  
19   

**Вывод:**    
181683441

### Примечания:  
Веса могут стать отрицательными после изменений.

# Cортировки 2

## [A. Объединение последовательностей](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/A.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Даны две бесконечных возрастающих последовательности чисел $A$ и $B$. i-ый член последовательности $A$ равен $i^2$. i-ый член последовательности $B$ равен $i^3$.  

Требуется найти $C_{x}$, где $C$ – возрастающая последовательность, полученная при объединении последовательностей $A$ и $B$. Если существует некоторое число, которое встречается и в последовательности $A$ и в последовательности $B$, то в последовательность $C$ это число попадает в единственном экземпляре.

### Формат ввода

В единственной строке входного файла дано натуральное число 
$x$ $(1≤x≤10^7)$.

### Формат вывода

В выходной файл выведите $C_{x}$.

### Пример 1 

**Ввод:**    
1  
 

**Вывод:**   
1

### Пример 2 

**Ввод:**  
2  

**Вывод:**    
4  


## [B. Сортировка слиянием](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/B.java)

| Ограничение времени | 4 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 128.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Отсортируйте данный массив, используя сортировку слиянием.

### Формат ввода

Первая строка входных данных содержит количество элементов в массиве $N$, $N≤10^5$. Далее идет $N$ целых чисел, не превосходящих по абсолютной величине $10^9$.


### Формат вывода

Выведите эти числа в порядке неубывания.

### Пример 1 

**Ввод:**    
1  
1  
 

**Вывод:**   
1

### Пример 2 

**Ввод:**  
2  
3 1  

**Вывод:**    
1 3  

### Пример 3 

**Ввод:**  
5  
5 4 3 2 1  

**Вывод:**    
1 2 3 4 5 


## [C. Быстрая сортировка](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/C.java)

| Ограничение времени | 4 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 128.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Отсортируйте данный массив, используя быструю сортировку.

### Формат ввода

Первая строка входных данных содержит количество элементов в массиве $N$, $0≤N≤10^5$. Далее идет $N$ целых чисел, не превосходящих по абсолютной величине $10^9$.


### Формат вывода

Выведите эти числа в порядке неубывания.

### Пример 1 

**Ввод:**    
2  
2 0
  
**Вывод:**   
0 2  

### Пример 2 

**Ввод:**  
7  
707064224 75267074 374155361 539523323 99604066 342179425 342194485
 

**Вывод:**    
75267074 99604066 342179425 342194485 374155361 539523323 707064224 


## [D. Задача про марки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/D.java)

| Ограничение времени | 1 секундa       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Максим коллекционирует марки. Известно, что всего у него $N$ марок, причем каждый вид марки может встречаться как один, так и несколько раз. Максиму стало интересно, сколько различных видов марок у него есть и он обратился за помощью к вам. Для вашего удобства он сопоставил каждому виду марки свой номер. Поэтому его коллекцию можно представить как массив натуральных чисел длины $N$. Помогите Максиму, сообщив, сколько различных видов марок у него есть.

### Формат ввода

В первой строке дано число $N$ $(1≤n≤100000)$. Во второй строке через пробел даны $N$ целых чисел $(1≤a[i]≤2∗10^9)$


### Формат вывода

Выведите число, равное количеству различных видов марок в коллекции Максима.

### Пример 1 

**Ввод:**    
5  
1 0 1 2 0
  
**Вывод:**   
3

## [E. Гражданская оборона](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/E.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки. Известно, что все $n$ селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги также расположены $m$ бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.  

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения определить ближайшее к нему бомбоубежище.

### Формат ввода

В первой строке вводится число $n$ - количество селений $(1≤n≤100000)$. Вторая строка содержит $n$ различных целых чисел, $i$-е из этих чисел задает расстояние от начала дороги до $i$-го селения. В третьей строке входных данных задается число $m$ - количество бомбоубежищ $(1≤m≤100000)$. Четвертая строка содержит m различных целых чисел, $i$-е из этих чисел задает расстояние от начала дороги до $i$-го бомбоубежища. Все расстояния положительны и не превышают $10^9$. Селение и убежище могут располагаться в одной точке.


### Формат вывода

Выведите $n$ чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища пронумерованы от $1$ до $m$ в том порядке, в котором они заданы во входных данных.

### Пример 1 

**Ввод:**    
4  
1 2 6 10  
2  
7 3  

**Вывод:**   
2 2 1 1 

## [F. Палиндром](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/F.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Палиндром - это строка, которая читается одинаково как справа налево, так и слева направо.
На вход программы поступает набор больших, маленьких латинских букв и символов «!*-+» (не обязательно различных). Разрешается переставлять буквы и символы, а также удалять их. Требуется из данных букв и символов по указанным правилам составить палиндром наибольшей длины, а если таких палиндромов несколько, то выбрать первый из них в порядке из таблицы ASCII.

### Формат ввода

В первой строке входных данных содержится число $(1≤n≤100000)$. Во второй строке задается последовательность из $n$ букв и символов (буквы и символы записаны без пробелов).


### Формат вывода

В единственной строке выходных данных выдайте искомый палиндром.

### Пример 1 

**Ввод:**    
3  
ABA

**Вывод:**   
ABA  

### Пример 2 

**Ввод:**    
6  
abcdef

**Вывод:**   
a

### Пример 3 

**Ввод:**    
6  
c++c++

**Вывод:**   
++cc++

## [G. Ирония судьбы, или салфетка с телефоном](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/sorting2/G.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В одной далекой стране Алгоритмии живут алгоритмяне и алгоритмянки. Однажды алгоритмянин позвал алгоритмянку на свидание, после которого она дала ему свой номер телефона. Однако, когда молодой человек пришел домой, он увидел что салфетка, на которой алгоритмянка написала свой телефон порвалась на n частей, на каждой из которых написана 1 или несколько цифр. Единственное, что вспомнил алгоритмянин - если поставить части телефона в правильном порядке, получится наибольшее число из возможных. Алгоритмянину очень понравилась алгоритмянка. Помогите восстановить ему номер телефона девушки, чтобы спасти их любовь!

### Формат ввода

В первой строке дается n - количество кусков салфетки. 1≤n≤100 Следующие n строк содержит от 1 до 100 цифр. Гарантируется, что хотя бы в одной строке первая цифра отлична от нуля.


### Формат вывода

Максимальное число, которое могло быть написано на салфетке.

### Пример 1 

**Ввод:**    
4  
95  
850  
75  
357  

**Вывод:**     
9585075357  

### Пример 2 

**Ввод:**    
4  
825  
6038  
44  
182  

**Вывод:**     
825603844182

### Пример 3 

**Ввод:**    
4  
202  
11  
071  
0346  

**Вывод:**     
202110710346
  
# Бинарный поиск

## [A. Левый и правый двоичный поиск](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/A.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дано два списка чисел, числа в первом списке упорядочены по неубыванию. Для каждого числа из второго списка определите номер первого и последнего появления этого числа в первом списке.

## Формат ввода  

В первой строке входных данных записано два числа $n$ и $m$ $(1≤n,m≤40000)$. Во второй строке записано $n$ упорядоченных по неубыванию целых чисел - элементы первого списка $A$. В третьей строке записаны $m$ целых неотрицательных чисел - элементы второго списка $B$. Все числа в списках - целые 32-битные знаковые.

## Формат вывода

Программа должна вывести $m$ строчек. Для каждого числа из второго списка нужно вывести номер его первого и последнего вхождения в первый список. Нумерация начинается с единицы. Если число не входит в первый список, нужно вывести одно число $0$.


### Пример

**Ввод:**

10 5  
1 1 3 3 5 7 9 18 18 57  
57 3 9 1 179  

**Вывод:**

10 10  
3 4  
7 7  
1 2  
0  

## [B. Приближенный двоичный поиск](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/B.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Реализуйте алгоритм приближенного бинарного поиска.

## Формат ввода  

В первой строке входных данных содержатся числа $N$ и $K$ $(0 < N,K < 100001)$. Во второй строке задаются $N$ чисел первого массива, отсортированного по неубыванию, а в третьей строке – $K$ чисел второго массива. Каждое число в обоих массивах по модулю не превосходит $2 * 10^{9}$

## Формат вывода

Для каждого из $K$ чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.

### Пример

**Ввод:**

5 5  
1 3 5 7 9   
2 4 8 1 6    

**Вывод:**

1  
3  
7  
1  
5  

## [C. Дипломы](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/C.java)

| Ограничение времени | 4 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось $n$ дипломов, причём, как оказалось, все они имели одинаковые размеры: $w$ — в ширину и $h$ — в высоту. Сейчас Петя учится в одном из лучших российских университетов и живёт в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить её к стене, а к ней — дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещён строго в прямоугольнике размером $w$ на $h$. Дипломы запрещается поворачивать на 90 градусов. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек. Требуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов.

## Формат ввода  

Входной файл содержит три целых числа: $w$,$h$,$n$ $(1≤w,h,n≤10^9)$.

## Формат вывода

В выходной файл необходимо вывести ответ на поставленную задачу.

### Пример 1

**Ввод:**

2 3 10
   
**Вывод:**

9

### Пример 2

**Ввод:**

1 1 1
   
**Вывод:**

1

## [D. Игрушки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/D.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Маленькая девочка собирает коллекцию из плюшевых игрушек. Каждая игрушка имеет свой уникальный цвет, но так как сложные слова, обозначающие оттенки цветов, ей сложно выговаривать, девочка запоминает цвета в качестве номеров (цветов не более $10^9$). Родители девочки попросили навести в комнате порядок, и она решила расставить игрушки в порядке возрастания номеров цветов. Помогите девочке посчитать, сколько игрушек каждого цвета находятся в ее комнате.

## Формат ввода  

В первой строке написано $N$ $(0≤N≤10^5)$ — количество игрушек.

В следующей строке находятся N отсортированных по возрастанию неотрицательных целых чисел, меньших $10^9$ — их цвета.

В третьей строке файла записано число $Q$ $(1≤Q≤10^6)$ — количество запросов вашей программе, в следующей строке через пробел записаны Q целых неотрицательных чисел $(≤10^{9}+1)$ - цвета искомых игрушек.

## Формат вывода

На каждый запрос выведите кол-во игрушек данного цвета

### Пример

**Ввод:**

10  
1 1 3 3 5 7 9 18 18 57  
5  
57 3 9 1 179  
   
**Вывод:**

1  
2  
1  
2  
0  

## [E. "Милая" игра в квадратики](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/E.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Биба и Боба любят играть в квадратики друг с другом. А ещё больше они любят играть в квадратики с другими людьми. Вы попали в подвал к Бибе и Бобе, и у Вас нет другого выбора, кроме как сыграть с ними в квадратики.

Игра состоит в том, что Биба и Боба вместе загадывают одно вещественное число $q$. Биба любит возводить в квадрат, а Боба любит брать квадратный корень, поэтому каждый из них преобразует выбранное число $q$ при помощи своей любимой операции ровно один раз. Далее они считают мегаквадрат $M$ равный сумме полученных чисел. Ваша задача - отгадать число $q$ по известному мегаквадрату $M$ с точностью не менее 6 знаков после точки. 

Вы должны успеть сказать Бибе и Бобе ответ за секунду, так как они не любят долго ждать, иначе они расстроятся и... (далее история умалчивается)

Как говорится, счастливых Вам квадратных игр!

## Формат ввода  

В единственной строке вводится вещественное число $(1.0≤M≤10^10)$.

## Формат вывода

Выведите одно число - искомый $q$.

### Пример 1

**Ввод:**

55.7441446377
 
   
**Вывод:**

7.2832272478

### Пример 2

**Ввод:**

1.0388558356
 
   
**Вывод:**

0.5470295764

### Пример 3

**Ввод:**

52.3211015024
   
**Вывод:**

7.0474392620

## [F. Коровы - в стойла](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/F.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

На прямой расположены стойла, в которые необходимо расставить коров так, чтобы минимальное расcтояние между коровами было как можно больше.

## Формат ввода  

В первой строке вводятся числа $N$ $(2<N<10001)$ – количество стойл и $K$ $(1<K<N)$ – количество коров. Во второй строке задаются $N$ натуральных чисел в порядке возрастания – координаты стойл (координаты не превосходят $10^9$)

## Формат вывода

Выведите одно число – наибольшее возможное допустимое расстояние.

### Пример 

**Ввод:**

6 3  
2 5 7 11 15 20  

**Вывод:**

9

## [G. Физика](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/BinSearch/G.py)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Недобросовестный студент Саша прогуливал пары по квантовой физике, и, когда пришло время делать домашнее задание, понял, что он ничего не знает. Поэтому он решил нанять себе решал Настю и Диму, чтобы те ему решили задачи.
Саше задано X задач. Так как Настя и Дима тоже студенты, они не могут решать задачи каждый день. Дима решает по A задач в день, но каждый K-й день он отдыхает и не решает задачи. Таким образом, Дмитрий отдыхает в K-й, 2K-й, 3K-й день, и т.д.
Настя решает по B задач в день, но каждый M-й день отдыхает.
Настя и Дима работают параллельно, и, когда они оба работают, они решают A + B задач по физике за день. Когда отдыхает только Настя — A задач, а когда отдыхает только Дима — B задач. В дни, когда оба студента не работают, они, очевидно, не решают ни одной задачи.
Так как Саша понимает, что дедлайн скоро, он решил выяснить, успеют ли Настя и Дима решить все задачи к установленному сроку.

## Формат ввода  

На вход подается 5 чисел A, K, B, M и X (1 ≤ A, B ≤ 10^9, 1 ≤ K, M ≤ 10^18, 1 ≤ X ≤ 10^18)

## Формат вывода

Требуется вывести одно число — количество дней, которое понадобится Насте и Диме, чтобы решить все задачи

### Пример 1

**Ввод:**

3 26 4 47 91

**Вывод:**

13

### Пример 2

**Ввод:**

2 22 8 19 96

**Вывод:**

10

### Пример 3

**Ввод:**

8 85 9 40 88

**Вывод:**

6

# Графы

## [A. Список смежности](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/A.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Напишите программу для преобразования матрицы смежности ориентированного, не взвешенного графа в список смежности. В графе может быть до 100 вершин.

## Формат ввода  

Первая строка содержит целое число n (1 ≤ n ≤ 100) — количество вершин в графе. Следующие n строк представляют матрицу смежности графа. Каждая строка содержит n чисел, разделённых пробелами. Каждое число равно 0 или 1, где 1 означает наличие направленного ребра от вершины i к вершине j, а 0 — его отсутствие.

## Формат вывода

Для каждой вершины графа в отдельной строке выводятся:
Целое число m — количество смежных с этой вершиной вершин.
Далее следуют m чисел, разделённых пробелами — номера смежных вершин. Вершины перечисляются в порядке возрастания номеров.

### Пример 1

**Ввод:**

4  
0 0 0 0  
1 0 1 0  
0 0 0 0  
0 0 0 0  

**Вывод:**

0  
2 1 3  
0  
0  


### Пример 2

**Ввод:**

6  
0 1 0 1 0 0  
0 0 0 0 0 0  
0 0 0 0 0 1  
0 0 0 0 0 0  
0 0 1 0 0 1  
0 0 0 1 0 0  

**Вывод:**

2 2 4  
0  
1 6  
0  
2 3 6  
1 4  

## [B. Дерево?](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/B.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Неориентированный граф без петель и кратных ребер задан матрицей смежности. Определить, является ли этот граф деревом.

## Формат ввода  

Сначала вводится число $N$ – количество вершин графа (от 1 до 100). Далее записана матрица смежности размером $N∗N$, в которой 1 обозначает наличие ребра, 0 – его отсутствие. Матрица симметрична относительно главной диагонали.

## Формат вывода

Введите сообщение YES, если граф является деревом, и NO в противном случае.

### Пример 1

**Ввод:**

2  
0 1  
1 0  
 
**Вывод:**

YES  

## [C. Истоки и стоки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/C.cpp)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Вершина ориентированного графа называется истоком, если в нее не входит ни одно ребро и стоком, если из нее не выходит ни одного ребра. Ориентированный граф задан матрицей смежности. Найдите все вершины графа, которые являются истоками, и все его вершины, которые являются стоками.

## Формат ввода  

Сначала вводится число $n$ $(1≤n≤3000)$– количество вершин в графе, а затем $n$ строк по $n$ чисел, каждое из которых равно 0 или 1 – его матрица смежности.

## Формат вывода

В начале выведите $k$ – число истоков в графе и затем $k$ чисел – номера вершин, которые являются истоками, в возрастающем порядке. Затем выведите информацию о стоках в том же порядке.

### Пример 1

**Ввод:**

5  
0 0 0 0 0   
0 0 0 0 1   
1 1 0 0 0   
0 0 0 0 0   
0 0 0 0 0  
 
**Вывод:**

2  
3  
4  
3  
1  
4  
5  

## [D. Обход графа](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/D.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дан неориентированный невзвешенный граф. Для него вам необходимо найти количество вершин, лежащих в одной компоненте связности с данной вершиной (считая эту вершину).

## Формат ввода  

В первой строке входных данных содержатся два числа: $N$ и $S$ $(1≤N≤100;1≤S≤N)$, где $N$ – количество вершин графа,а $S$ – заданная вершина. В следующих $N$ строках записано по N чисел – матрица смежности графа, в которой 0 означает отсутствие ребра между вершинами, а 1 – его наличие. Гарантируется, что на главной диагонали матрицы всегда стоят нули.

## Формат вывода

Выведите одно целое число – искомое количество вершин.

### Пример 1

**Ввод:**

5 1  
0 1 1 0 0  
1 0 1 0 0  
1 1 0 0 0  
0 0 0 0 0  
0 0 0 0 0  

**Вывод:**

3
  
## [E. Один конь](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/E.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

На шахматной доске $N*N$ в клетке $(x1,y1)$ стоит голодный шахматный конь. Он хочет попасть в клетку $(x2,y2)$, где растет вкусная шахматная трава. Какое наименьшее количество ходов он должен для этого сделать?

## Формат ввода  

На вход программы поступает пять чисел: $N$, $x1$, $y1$, $x2$, $y2$ $(5≤N≤20,1≤x1,y1,x2,y2≤N)$. Левая верхняя клетка доски имеет координаты $(1, 1)$, правая нижняя - $(N,N)$.

## Формат вывода

В первой строке выведите единственное число $K$ - наименьшее необходимое число ходов коня.

### Пример 1

**Ввод:**

5  
1 1  
3 2  

**Вывод:**

1

## [F. Есть ли цикл?](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/F.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дан ориентированный граф. Требуется определить, есть ли в нем цикл.

## Формат ввода  

В первой строке вводится число вершин $N≤50$. Далее в $N$ строках следуют по $N$ чисел, каждое из которых – 0 или 1. $j$−ое число в $i$−ой строке равно 1 тогда и только тогда, когда существует ребро, идущее из $i$−ой вершины в $j$−ую. Гарантируется, что на диагонали матрицы будут стоять нули.

## Формат вывода

Выведите 0, если в заданном графе цикла нет, и 1, если он есть.

### Пример 1

**Ввод:**

3  
0 1 0  
0 0 1  
0 0 0  
  
**Вывод:**

0

## [G. Самая удаленная вершина](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/G.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дано неориентированное невзвешенное дерево. Требуется найти самую удаленную вершину от данной.

## Формат ввода  

первой строке дано число $n$ — количество вершин дерева и число $k$ — номер вершины, для которой нужно найти самую удаленную от нее $(1 ≤k≤n≤ 100)$. Далее в $n$ строках дана матрица смежности дерева.

## Формат вывода

Выведите номер самой удаленной вершины от данной. Если таких вершин несколько, выведите наименьший номер.

### Пример 1

**Ввод:**

4 2  
0 1 0 1  
1 0 1 0  
0 1 0 0  
1 0 0 0  
 
**Вывод:**

4

## [H. Поливальная машина](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/H.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Город $N$, в отличие от города $M$, расположен на склоне одного холма. Чистоту улиц этого города обеспечивает единственная поливальная машина. Бензин нынче дорог, поэтому движение муниципального транспорта «в гору» признано слишком расточительным.

Карта города представляет собой прямоугольник, разбитый на $H ∗ W$ клеток, где $H$ и $W$ — высота и ширина карты в клетках соответственно. Часть клеток заняты зданиями, остальные соответствуют улицам и площадям, которые и требуется помыть.

Поливальная машина начинает свой путь в одной из клеток самого верхнего ряда, не занятой зданиями. Она может полить асфальт в текущей клетке и переместиться в любую из двух соседних клеток этого же ряда, не занятых зданиями. Объехать здания, не поднимаясь при этом в гору, невозможно. Поливальная машина также может переместиться в соседнюю по вертикали свободную клетку из нижнего ряда.

Помогите узнать экономному муниципалитету, какое максимальное количество свободных клеток поливальная машина сможет помыть, не поднимаясь при этом в гору?

Учтите, что структура города такова, что в каждом ряду свободные клетки образуют один непрерывный отрезок.

## Формат ввода  

В первой строке входного файла находятся натуральные числа $H$ и $W$ — высота и ширина карты города $(1 ≤ W ≤ 300,1 ≤ H≤ 300)$.

Каждая из следующих $H$ строк содержит $W$ символов ‘#’ и ‘.’, означающих, соответственно, клетки со зданиями и без.

## Формат вывода

Выведите единственное натуральное число — максимальную площадь, которую может обработать поливалка.

### Пример 1

**Ввод:**

8 8  
###...##  
#...####  
##.#####  
##..####  
......##  
####...#  
#...####  
#.....##  

**Вывод:**

18

## [I. Квест](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs/I.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дима проходит квест. Чтобы пройти квест до конца, ему необходимо открыть каждый из N ящиков, стоящих на пути к выходу. За каждый ящик, открытый самостоятельно, Диме дают 1 балл. Дима может открыть ящик ключом, но, если у него такового нет, он может попросить организаторов открыть этот ящик, но балл он тогда не получит. Каждый ящик может быть открыт единственным соответствующим ему ключом или открыт организаторами.
На входе в квест Диме дают информацию, в каком ящике лежит какой ключ. Конечно, Дима хочет попросить организаторов квеста открыть как можно меньше ящиков, чтобы получить максимальное количество баллов. Помогите Диме определить, какое минимальное количество ящиков придется открыть организаторам.

## Формат ввода  

В первой строке содержится число $N$ — количество ящиков $(1≤N≤100000)$. Далее идет $N$ строк с описанием того, где лежит ключ от какого ящика: в i-ой из этих строк записан номер ящика, в котором находится ключ от i-го ящика.

## Формат вывода

Выведите единственное число: минимальное количество ящиков, которые придется открыть организаторам.

### Пример 1

**Ввод:**

5  
3  
5  
2  
1  
4  

**Вывод:**

1

### Пример 2

**Ввод:**

5  
4  
5  
5  
1  
2  

**Вывод:**

2

### Пример 3

**Ввод:**

5  
3  
5  
1  
2  
3  

**Вывод:**

1

# Графы 2

## [A. Производство деталей](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/A.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Предприятие «Авто-2010» выпускает двигатели для известных во всём мире автомобилей. Двигатель состоит ровно из n деталей, пронумерованных от 1 до n, при этом деталь с номером i изготавливается за pi секунд. Специфика предприятия «Авто-2010» заключается в том, что там одновременно может изготавливаться лишь одна деталь двигателя. Для производства некоторых деталей необходимо иметь предварительно изготовленный набор других деталей.
Генеральный директор «Авто-2010» поставил перед предприятием амбициозную задачу — за наименьшее время изготовить деталь с номером 1, чтобы представить её на выставке.

Требуется написать программу, которая по заданным зависимостям порядка производства между деталями найдёт наименьшее время, за которое можно произвести деталь с номером 1.

## Формат ввода  

Первая строка входного файла содержит число $n$ $(1≤ n≤ 100000)$ — количество деталей двигателя. Вторая строка содержит n натуральных чисел $p_1,p_2,…,p_n$, определяющих время изготовления каждой детали в секундах. Время для изготовления каждой детали не превосходит $10^9$ секунд.

Каждая из последующих $n$ строк входного файла описывает характеристики производства деталей. Здесь $i$-я строка содержит число деталей $k_i$, которые требуются для производства детали с номером $i$, а также их номера. В $i$-й строке нет повторяющихся номеров деталей. Сумма всех чисел $k_i$ не превосходит 200000.

Известно, что не существует циклических зависимостей в производстве деталей.

## Формат вывода

В первой строке выходного файла должны содержаться два числа: минимальное время (в секундах), необходимое для скорейшего производства детали с номером $1$ и число $k$ деталей, которые необходимо для этого произвести. Во второй строке требуется вывести через пробел $k$ чисел — номера деталей в том порядке, в котором следует их производить для скорейшего производства детали с номером $1$.

### Пример 1

**Ввод:**

3  
100 200 300  
1 2  
0  
2 2 1  
  
**Вывод:**

300 2  
2 1  


### Пример 2

**Ввод:**

2  
2 3  
1 2  
0  

**Вывод:**

5 2  
2 1  

## [B. Построение](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/B.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Группа солдат-новобранцев прибыла в армейскую часть №$\sqrt{π}$. После знакомства с прапорщиком стало очевидно, что от работ на кухне по очистке картофеля спасти солдат может только чудо.

Прапорщик, будучи не в состоянии запомнить фамилии, пронумеровал новобранцев от 1 до $N$. После этого он велел им построиться по росту (начиная с самого высокого). С этой несложной задачей могут справиться даже совсем необученные новобранцы, да вот беда, прапорщик уверил себя, что знает про некоторых солдат, кто из них кого выше, и это далеко не всегда соответствует истине.

После трех дней обучения новобранцам удалось выяснить, что знает (а точнее, думает, что знает) прапорщик. Помогите им, используя эти знания, построиться так, чтобы товарищ прапорщик остался доволен.

## Формат ввода  

Сначала на вход программы поступают числа $N$ и $M$ $(2 ≤ N ≤ 100; 1 ≤ M ≤ 5000 )$ — количество солдат в роте и количество пар солдат, про которых прапорщик знает, кто из них выше. Далее идут эти пары чисел $А$ и $В$ по одной на строке $(1 ≤ А, В ≤ N)$, что означает, что, по мнению прапорщика, солдат $А$ выше, чем $В$.

## Формат вывода

В первой строке выведите «Yes» (если можно построиться так, чтобы прапорщик остался доволен) или «No» (если нет). После ответа «Yes» на следующей строке выведите N чисел, разделенных пробелами, — одно из возможных построений.

### Пример 1

**Ввод:**

5 4  
1 3  
1 4  
4 3  
5 2  

  
**Вывод:**

Yes  
5 2 1 4 3 

## [C. Неизбежность](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/C.java)

| Ограничение времени | 5 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Семён живет в первой вершине связного неориентированного графа, состоящего из $n$ вершин и $m$ ребер. Каждый день он ходит в школу, находящуюся в вершине с номером $n$. Семён старается каждый день ходить в школу новым маршрутом, однако однажды он заметил, что некоторые ребра он проходит каждый день, независимо от того, каким маршрутом идет. Помогите Семёну найти все такие ребра.

## Формат ввода  

Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно     $(1 ≤ n ≤ 20 000, 1 ≤ m ≤ 200 000)$.

Следующие $m$ строк содержат описание рёбер по одному на строке. Ребро под номером $i$ описывается двумя натуральными числами $b_i$, $e_i$ — номерами вершин-концов ребра $(1 ≤ b_i, e_i ≤ n)$.

## Формат вывода

Первая строка выходного файла должна содержать одно натуральное число $b$ — количество ребер, которые неизбежно встречаются на пути Семёна. На следующей строке выведите $b$ целых чисел — номера этих ребер в возрастающем порядке. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

### Пример 1

**Ввод:**

7 8  
1 2  
2 3  
1 3  
3 4  
4 5  
5 6  
4 6  
6 7  

  
**Вывод:**

2  
4 8   

## [D. Мосты](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/D.cpp)

| Ограничение времени | 5 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дан неориентированный граф. Требуется найти все мосты в нём.

## Формат ввода  

Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно $(1 ≤ n ≤ 20 000, 1 ≤ m ≤ 200 000)$.
Следующие m строк содержат описание рёбер по одному на строке. Ребро под номером i описывается двумя натуральными числами $b_i$, $e_i$ — номерами вершин-концов ребра $(1 ≤ b_i, e_i ≤ n)$.

## Формат вывода

Первая строка выходного файла должна содержать одно натуральное число $b$ — количество мостов в заданном графе. На следующей строке выведите $b$ целых чисел — номера рёбер, которые являются мостами, в возрастающем порядке. Рёбра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

### Пример 1

**Ввод:**

6 7  
1 2  
2 3  
3 4  
1 3  
4 5  
4 6  
5 6  

**Вывод:**

1  
3  

## [E. Точки сочленения](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/E.java)

| Ограничение времени | 5 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дан неориентированный граф. Требуется найти все точки сочленения в нём.

## Формат ввода  

Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно $(1 ≤ n ≤ 20 000, 1 ≤ m ≤ 200 000)$.
Следующие m строк содержат описание рёбер по одному на строке. Ребро под номером i описывается двумя натуральными числами $b_i$, $e_i$ — номерами вершин-концов ребра $(1 ≤ b_i, e_i ≤ n)$.

## Формат вывода

Первая строка выходного файла должна содержать одно натуральное число $b$ — количество точек сочленения в заданном графе. На следующей строке выведите $b$ целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке.

### Пример 1

**Ввод:**

9 12  
1 2  
2 3  
4 5  
2 6  
2 7  
8 9  
1 3  
1 4  
1 5  
6 7  
3 8  
3 9  

**Вывод:**

3  
1 2 3  

## [F. Магнитные подушки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/F.cpp)

| Ограничение времени | 5 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Город будущего застроен небоскребами, для передвижения между которыми и парковки транспорта многие тройки небоскребов соединены треугольной подушкой из однополярных магнитов. Каждая подушка соединяет ровно 3 небоскреба и вид сверху на нее представляет собой треугольник, с вершинами в небоскребах. Это позволяет беспрепятственно передвигаться между соответствующими небоскребами. Подушки можно делать на разных уровнях, поэтому один небоскреб может быть соединен различными подушками с парами других, причем два небоскреба могут соединять несколько подушек (как с разными третьими небоскребами, так и с одинаковым). Например, возможны две подушки на разных уровнях между небоскребами $1$, $2$ и $3$, и, кроме того, магнитная подушка между $1$, $2$, $5$.  
Система магнитных подушек организована так, что с их помощью можно добираться от одного небоскреба, до любого другого в этом городе (с одной подушки на другую можно перемещаться внутри небоскреба), но поддержание каждой из них требует больших затрат энергии.

Требуется написать программу, которая определит, какие из магнитных подушек нельзя удалять из подушечной системы города, так как удаление даже только этой подушки может привести к тому, что найдутся небоскребы из которых теперь нельзя добраться до некоторых других небоскребов, и жителям станет очень грустно.

## Формат ввода  

В первой строке входного файла находятся числа $N$ и $M$ — количество небоскребов в городе и количество работающих магнитных подушек соответственно $(3 ≤ N ≤ 100000, 1 ≤ M ≤ 100000)$. В каждой из следующих $M$ строк через пробел записаны три числа — номера небоскребов, соединенных подушкой. Небоскребы пронумерованы от $1$ до $N$. Гарантируется, что имеющиеся воздушные подушки позволяют перемещаться от одного небоскреба до любого другого.

## Формат вывода

Выведите в выходной файл сначала количество тех магнитных подушек, отключение которых невозможно без нарушения сообщения в городе, а потом их номера в порядке возрастания. Нумерация должна соответствовать тому порядку, в котором подушки перечислены во входном файле. Нумерация начинается с единицы.

### Пример 1

**Ввод:**

3 1  
1 2 3  

**Вывод:**

1  
1  

### Пример 2

**Ввод:**

3 2  
1 2 3  
3 2 1  
 
**Вывод:**

0 

### Пример 3

**Ввод:**

5 4  
1 2 3  
2 4 3  
1 2 4  
3 5 1  

**Вывод:**

1    
4  

## [G. Конденсация](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs2/G.java)

| Ограничение времени | 5 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Вам задан ориентированный граф с $n$ вершинами и $m$ ребрами. Найдите компоненты сильной связности заданного графа и топологически отсортируйте его конденсацию.

## Формат ввода  

Граф задан во входном файле следующим образом: первая строка содержит числа $n$ $(1≤n≤2⋅10^4)$ и $m$ $(1≤m≤min(\frac{n⋅(n-1)}{2}, 2 ⋅ 10^5))$

Каждая из следующих $m$ строк содержит описание ребра – два целых числа в диапазоне от $1$ до $n$ – номера начала и конца ребра.

## Формат вывода

На первой строке выведите число $k$ – количество компонент сильной связности в заданном графе.   
На следующей строке выведите $n$ чисел – для каждой вершины выведите номер компоненты сильной связности, которой принадлежит эта вершина. Компоненты сильной связности должны быть занумерованы таким образом, чтобы для любого ребра номер компоненты сильной связности его начала не превышал номера компоненты сильной связности его конца.

### Пример 1

**Ввод:**

10 19  
1 4  
7 8  
5 10  
8 9  
9 6  
2 6  
6 2  
3 8  
9 2  
7 2  
9 7  
4 5  
3 6  
7 3  
6 7  
10 8  
10 1  
2 9  
2 7  
 
**Вывод:**

2  
1 2 2 1 1 2 2 2 2 1   
 
# Графы 3

## [A. Алгоритм Дейкстры](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs3/A.cpp)

| Ограничение времени | 1.2 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В данной задаче предлагается реализовать **алгоритм Дейкстры** для поиска всех кратчайших путей из вершины 0 в остальные в **ориентированном графе**.

## Формат ввода  

На вход программы подается информация о слабо-связном ориентированном взвешенном графе в следующем формате:

В первой строке два целых числа $n$ $(2≤n≤10^5)$ и $m$ $(n−1≤m≤min(n⋅(n−1),2⋅10^5))$ – количество вершин и дуг в графе соответственно. Все $n$ вершин имеют номера, нумерация вершин от $0$ до $n−1$.

В следующих $m$ строках содержатся по $3$ числа: $u$ $v$ $w$ $(u \neq v;0≤u,v≤n−1;1≤w≤10^9)$, где $u$ и $v$ – номера вершин, которые связывает дуга (путь из $u$ в $v$), а $w$ – стоимость (вес) дуги.

Одну и ту же пару вершин соединяет не более двух дуг различной ориентации (для вершин $u$ и $v$ может быть и дуга $(u,v)$, и дуга $(v,u)$). Гарантируется, что из вершины $0$ существует путь до всех остальных вершин.

## Формат вывода

В каждой строке требуется, требуется вывести длину пути от вершины под номером $0$ до вершины с номером, соответствующим номеру строки (нумерация строк с $1$)

### Пример 1

**Ввод:**

5 10  
0 1 5  
0 3 3  
0 4 8  
1 2 4  
2 1 7  
2 3 9  
3 1 2  
4 0 6  
4 2 10  
4 3 1  
 
**Вывод:**

5  
9  
3  
8  

### Пример 2

**Ввод:**

6 13  
0 2 5  
1 0 7  
1 5 11  
2 4 4  
2 5 1  
3 1 10  
3 2 9  
3 4 3  
3 5 2  
4 2 8  
5 0 13  
5 3 12  
5 4 6  
  
**Вывод:**

28  
5  
18  
9  
6  

## [B. Минимальный каркас](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs3/B.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

От вас требуется определить вес минимального остовного дерева для неориентированного взвешенного связного графа.

## Формат ввода  

В первой строке входных данных находятся числа $N$ и $M$ $(2 <= N <= 20000; 1 <= M <= 100000)$, где $N$ – количество вершин в графе, а $M$ – количество рёбер. В каждой из последующих $M$ строк записано по тройке чисел $A$, $B$, $C$, где 
$A$ и $B$ – номера вершин, соединённых ребром, а $C$ – вес ребра (натуральное число, не превышающее 1000000)

## Формат вывода

Вывести одно число – искомый вес.

### Пример 1

**Ввод:**

3 3  
1 2 1  
2 3 2  
3 1 3  
 
**Вывод:**

3 

## [C. Олимпиада по алхимии](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs3/C.cpp)

| Ограничение времени | 3 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 128.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

На всем известной красной планете после успешной высадки людей было основано новое государство, состоящее из $n$ городов, которые для удобства получили номера от $1$ до $n$. Их некоторым образом соединяют $m$ сверхинновационных дорог, для каждой из которых известно время, которое необходимо затратить, чтобы добраться по ней из одного города в другой.

Кроме того, в результате всеобщего голосования, была выбрана столица, в которой расположились главные научные центры. Это позволило в скором времени совершить в столице открытие, ранее считавшееся невозможным. Конечно, в первую очередь, необходимо оповестить о нем людей в $k$ определенных городах. Для доставки сообщения используются колесные роботы, способные передвигаться по дорогам. Все роботы выезжают из столицы одновременно.

Ваша задача - узнать в каком порядке и через какое время роботы доставят сообщения во все нужные города. Во время всего пути роботы непрерывно едут, пока не достигнут точки назначения. Временем на пересечение городов можно пренебречь.

## Формат ввода  

В первой строке записаны четыре числа $n$,$m$,$k$,$c$ 
$(2≤n≤10^5,1≤m≤2⋅10^5,1≤k≤n,1≤c≤n)$ — количество городов, количество дорог, количество городов, в которые необходимо доставить сообщение и номер столицы.

Во второй строке даны $k$ чисел, задающие номера городов, в которые необходимо доставить сообщение.

В следующих строках располагаются $m$ троек чисел $s_i$, $f_i$, $t_i$ $(1≤s_i≤n,1≤f_i≤n,s_i \neq f_i, 1≤t_i≤100)$, описывающих дороги - $s_i$, $f_i$ - номера городов, которые соединяет описываемая дорога, а $t_i$ - время, которое необходимо затратить, чтобы проехать по данной дороги из города $s_i$ в $f_i$.

Гарантируется, что все города достижимы из столицы.

## Формат вывода

Необходимо вывести $k$ пар чисел - для каждого города, в которое должно быть доставлено сообщение, требуется вывести его номер, а также минимальное время, через которое робот доберется до него.

Итоговые пары значений должны быть упорядочены по возрастанию времени прибытия робота в заданный ему населенный пункт. При равенстве времен упорядочивать по возрастанию номера города.


### Пример 1

**Ввод:**

5 4 5 1  
1 2 3 4 5  
1 2 1  
2 3 10  
3 4 100  
4 5 100  

**Вывод:**

1 0  
2 1  
3 11  
4 111  
5 211  

### Пример 2

**Ввод:**

5 5 3 1  
2 4 5  
2 1 1  
2 3 10  
3 4 100  
4 5 100  
1 5 1  

**Вывод:**

2 1  
5 1  
4 101  

## [D. Путешествие](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs3/D.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В государстве Z есть ряд населенных пунктов, соединенных сетью трасс. Для проезда по каждому участку пути израсходуется полный резервуар топлива. Стоимость топлива в каждом населенном пункте различна. Задача состоит в том, чтобы осуществить перемещение из пункта А в пункт B, минимизировав финансовые затраты на бензин. Запасать топливо заранее не допускается.

## Формат ввода  

В первой строке задается количество населенных пунктов Z (1≤Z≤100). Во второй строке перечислены Z чисел, где i-е число определяет цену топлива в i-м населенном пункте (целые числа от 0 до 100). После этого следует число R — количество трасс, а далее — информация о самих трассах. Каждая трасса описывается парой чисел — индексами населенных пунктов, которые она связывает. Все трассы двунаправленные (по ним можно передвигаться в обоих направлениях), между любыми двумя населенными пунктами существует не более одной трассы, и нет трасс, ведущих из населенного пункта в него же.

## Формат вывода

Необходимо вывести единственное число — общую стоимость пути из пункта А в пункт B или -1, если маршрут невозможен.

### Пример 1

**Ввод:**

5  
3 6 1 7 6   
8  
1 2  
5 4  
5 1  
3 4  
5 2  
2 4  
2 3  
3 1   

**Вывод:**

3   

## [E. Порталы](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs3/E.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Одно волшебное королевство, разделенное на несколько островов, решило соединиться с помощью магических порталов. Есть определённый план очередности постройки порталов. По порталам можно передвигаться в обе стороны и после установки всех порталов жители смогут путешествовать между всеми островами (возможно, через некоторые промежуточные острова). Допускаются порталы внутри одного острова и несколько порталов между одними и теми же островами.
Ваша задача состоит в определении минимального количества порталов, которые необходимо установить, чтобы можно было попасть с любого острова на любой другой, следуя порядку установки по плану.

## Формат ввода  

Первая строка содержит два числа: $N$ - число островов $(1 ≤ N ≤ 100000)$ и $М$ - количество порталов в плане $(1 ≤ М ≤ 200000)$. В каждой следующей строке содержится описание портала - два числа $х$ и $у$ $(0 ≤ х, у < N)$ - номера соединяемых островов.

## Формат вывода

Выведите в выходной файл одно число – минимальное количество построенных порталов, по которым можно попасть с любого острова на любой.

### Пример 1

**Ввод:**

4 5  
0 1  
0 2  
1 2  
2 3  
3 0  
  

**Вывод:**

4

## [F. Подъем](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Graphs3/F.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Как многие помнят из контрольного контеста, Дима купил Насте все цветы в городе. Теперь ему нужно поднять их на этаж, где живет Настя. Очевидно, один он с этим не справится, поэтому он нанял грузчиков. За подъем по лестнице на один этаж требуется заплатить U рублей, за спуск по лестнице на один этаж — D рублей, за внос в лифт — I рублей, за вынос из лифта — J рублей. Настя живет в дорогом доме, поэтому в ее доме есть L лифтов, каждый из которых останавливается лишь на определенных этажах. Помогите Диме разработать маршрут подъема букетов с первого этажа, стоимость которого наименьшая.

## Формат ввода  

В первой строке входного файла записаны целые числа N, U, D, I, J, L. Каждая из следующих L строк описывает соответствующий лифт. Она начинается с числа Ki — количества этажей, на которых останавливается i-й лифт, за которым следует Ki натуральных чисел — этажи, на которых останавливается этот лифт (этажи для каждого лифта задаются в возрастающем порядке). 0≤U≤1000, 0≤D≤1000, 0≤I≤1000, 0≤J≤1000, 0≤L≤500, 1≤N≤1000000, 1≤Ki≤1000, K1+K2+…+KL≤100000. Количество этажей в небоскребе не превосходит 1000000.

## Формат вывода

Выведите одно число — минимальную стоимость подъема букетов.

### Пример 1

**Ввод:** 
  
9 3 7 3 7 1  
1 1  

**Вывод:**

24

### Пример 2

**Ввод:**

5 4 1 2 3 1  
1 3  

**Вывод:**

16

### Пример 3

**Ввод:**
  
4 6 10 9 7 1  
1 1  

**Вывод:**

18

# Динамика

## [A. Обратный кузнечик](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Dynamic/A.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

На вершине лесенки, содержащей $n$ ступенек, сидит кузнечик, который хочет спуститься вниз, к основанию. Кузнечик умеет прыгать на следующую ступеньку, на ступеньку через одну или через две. Например, если кузнечик сидит на 6-ой ступеньке, то он может прыгнуть на 3-ую, 4-ую или 5-ую ступеньку. Кузнечик всегда прыгает **только вниз**.

Ваша задача - посчитать количество всевозможных **маршрутов** кузнечика для спуска с последней ступеньки до основания.

Так как количество маршрутов **может быть очень большим**, Вам необходимо вывести ответ **по модулю** $10^9 + 7$.

## Формат ввода  

Вводится одно целое число $n$ $(1≤n≤10^5)$ – количество ступенек.

## Формат вывода

Выведите одно число - количество маршрутов кузнечика.

### Пример 1

**Ввод:** 
  
4 

**Вывод:**

7

### Пример 2

**Ввод:**

1 

**Вывод:**

1

### Пример 3

**Ввод:**
  
7 

**Вывод:**

44


## [B. Черепашка и монетки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Dynamic/B.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В верхнем левом углу прямоугольной таблицы размером $n∗m$ сидит черепашка и предвкушает несметные богатства. Дело в том, что именно сегодня прошел легендарный монетный дождь, и теперь в каждой ячейке таблицы лежит некоторое количество монет.

По природе своей черепашка может двигаться либо в правую соседнюю клетку, либо в нижнюю соседнюю и никуда иначе. Также, по той же причине, у нее есть непреодолимое желание закончить свой маршрут в правой нижней клетке таблицы.

На этот раз, Ваша задача - определить максимальное количество монеток, которое сможет собрать черепашка, а также построить для нее маршрут, на котором это максимальное количество монеток будет достигнуто.

## Формат ввода  

В первой строке находится два натуральных числа 
$n$ и $m$ $(1≤n,m≤100)$ – размеры таблицы.

Далее идет $n$ строк, каждая из которых содержит $m$ чисел, разделенных пробелами — количество монет в каждой ячейке таблицы. Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.

## Формат вывода

В первую строку необходимо вывести максимально возможное количество монет, которые может собрать черепашка.

Во второй строке должен быть выведен маршрут, на котором достигается это количество.

Маршрут представляет собой последовательность, которая должна содержать $n−1$ букву $D$, означающую передвижение в нижнюю соседнюю клетку, а также $m−1$ букву $R$, означающую передвижение в правую соседнюю клетку. Буквы разделяются строго одним пробелом.

Если таких маршрутов несколько, допускается вывести любой из них.

### Пример 1

**Ввод:** 
  
1 1
179 

**Вывод:**

179

### Пример 2

**Ввод:**

2 2  
1 2  
3 1  

**Вывод:**

5  
D R   

### Пример 3

**Ввод:**
  
5 5  
9 9 9 9 9  
3 0 0 0 0  
9 9 9 9 9  
6 6 6 6 8  
9 9 9 9 9  

**Вывод:**

74  
D D R R R R D D   

## [C. Задача о шахматном коне](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Dynamic/C.py)

| Ограничение времени | 0.1 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дано поле $n×m$ клеток, конь стоит в левой верхней клетке $(0,0)$. Он может ходить буквой **Γ** (как в шахматах), но есть всего $4$ варианта движения (смотрите картинку).
![Варианты ходов](https://github.com/mishcum/Algorithms-and-data-structures/blob/95d4ed41d82c61f2727fbf39d28454614c0d353a/Dynamic/image.png)
Надо вычислить сколько различных способов добраться до клетки $(n−1,m−1)$, если нумерация строк и столбцов начинается с нуля.

## Формат ввода  

Два числа: $n$ $(1≤n≤50)$ и $m$ $(1≤m≤30)$ – количество строк и столбцов доски соответственно.

Доска может быть не квадратной, то есть возможны примеры, когда $n \neq m$.

## Формат вывода

s – количество способов добраться конем из клетки $(0,0)$ в клетку $(n−1,m−1)$.

### Пример 1

**Ввод:** 
  
5 5

**Вывод:**

4

### Пример 2

**Ввод:**

4 8  

**Вывод:**

8 

### Пример 3

**Ввод:**
  
10 5

**Вывод:**

64 

## [D. Задача о камнях](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Dynamic/D.cpp)

| Ограничение времени | 0.4 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Задача о камнях.
Имеется $n$ камней с разными весами $p_i$. Необходимо найти набор камней с максимальным суммарным весом, не превосходящим $w$.

Необходимо решить задачу, используя динамическое программирование.

## Формат ввода  

На вход поступает $3$ строки:
В первой строке число $n$ $(1≤n≤1000)$ – количество доступных камней.

Во второй строке число $w$ $(0≤w≤50000)$ – ограничение на максимальный вес.

В третьей строке $n$ чисел $p_i$ $(1≤p_i≤8000)$ – веса доступных камней.

Набор упорядочен по возрастанию веса, но могут встречаться камни одинакового веса.

## Формат вывода

Запишите $3$ строки:
В первой строке число $a$ – суммарный вес всех камней, вошедших в решение.

Во второй строке число $m$ – количество камней, вошедших в решение.

В третьей строке $m$ чисел – веса взятых камней.

Все веса должны быть из входных данных и следовать в неубывающем порядке.

### Пример 1

**Ввод:** 
  
5  
20  
3 3 6 9 12   

**Вывод:**

18  
2  
6 12   

### Пример 2

**Ввод:**

5  
19  
5 7 9 11 13   

**Вывод:**

18  
2  
7 11   

### Пример 3

**Ввод:**
  
10  
47  
1 2 3 4 5 6 7 8 9 10  

**Вывод:**

47  
9  
1 2 3 4 5 6 7 9 10     

## [E. Задача о жадном рюкзаке](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Dynamic/E.cpp)

| Ограничение времени | 0.3 секунд       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Необходимо решить задачу, используя жадный алгоритм. **Он не решает задачу оптимально**.

Задан максимально возможный подъемный вес рюкзака $w$. Необходимо найти набор предметов максимальной стоимости, общий вес которого не больше $w$.

Могут возникнуть неоднозначные ситуации, руководствуемся таким правилом:

Если оба предмета имеют одинаковую удельную стоимость, то берем тот, который весит больше (если он помещается в рюкзак соответственно).
Пример: $n=2, w=10,$ предметы:  
  * $p_1 = 7, c_1 = 70$.  
  * $p_2 = 5, c_2 = 50$.
Тогда правильный ответ: предмет $p_1 = 7, c_1 = 70$, так как он больше весит и входит в рюкзак.

## Формат ввода  

В первой строке целое число $n$ $(1≤n≤1000)$ – количество доступных предметов.

Во второй строке целое число $w$ $(0≤w≤50000)$ – ограничение на максимальный вес рюкзака.

В третьей строке $n$ целых чисел – веса доступных предметов $p_i$ $(1≤p_i≤2000)$. Могут встречаться предметы одинакового веса.

В четвертой строке $n$ целых чисел – стоимости доступных предметов $c_i$ $(1≤c_i≤10^9)$. Могут встречаться предметы одинаковой стоимости.

**Набор предметов никак не упорядочен.**

## Формат вывода

В первой строке число $a$ – это суммарная стоимость всех предметов, вошедших в решение.

Во второй строке число $b$ – суммарный вес всех предметов, вошедших в решение.

В третьей строке число $m$ – количество предметов, вошедших в решение.

В четвертой строке $m$ чисел – веса взятых предметов.

В пятой строке $m$ чисел – стоимости взятых предметов.

Все комбинации весов и стоимостей должны быть из входных данных. Можно выводить их в ответ в любом порядке (но не нарушая комбинаций вес-стоимость).

### Пример 1

**Ввод:** 
  
6  
10  
3 2 4 1 3 1  
55 80 60 45 105 50  

**Вывод:**

335  
10  
5  
3 3 2 1 1   
105 55 80 50 45   

### Пример 2

**Ввод:**

6  
10  
1 2 3 4 5 6  
10 20 30 40 50 60  

**Вывод:**

100  
10  
2  
6 4   
60 40    

### Пример 3

**Ввод:**
  
10  
30  
1 14 18 7 9 9 6 12 19 1   
4 9 4 1 2 10 13 14 10 18   

**Вывод:**

59  
29  
5  
12 9 6 1 1   
14 10 13 18 4    

## [F. Задача о рюкзаке с восстановлением ответа](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/Dynamic/F.cpp)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Есть рюкзак, который может поднять максимально возможный вес $w$. Также задан набор предметов, каждый предмет имеет два параметра – вес $p$ и стоимость $c$. Необходимо найти набор предметов максимальной стоимости, вес набора предметов не больше $w$.

## Формат ввода  

В первой строке целое число $n$ $(1≤n≤100)$ – количество доступных предметов.

Во второй строке целое число $w$ $(0≤w≤10000)$ – максимальный вес, который выдерживает рюкзак.

В третьей строке $n$ целых чисел – веса доступных предметов $p_i$ $(1≤p_i≤100)$. Могут встречаться предметы одинакового веса.

В четвертой строке $n$ целых чисел – стоимости доступных предметов $c_i$ $(1≤c_i≤10^9)$. Могут встречаться предметы одинаковой стоимости.


**Набор предметов никак не упорядочен.**

## Формат вывода

В первой строке число $a$ – это суммарная стоимость всех предметов, вошедших в решение.

Во второй строке число $b$ – суммарный вес всех предметов, вошедших в решение.

В третьей строке число $m$ – количество предметов, вошедших в решение.

В четвертой строке $m$ чисел – веса взятых предметов.

В пятой строке $m$ чисел – стоимости взятых предметов.

Все комбинации весов и стоимостей должны быть из входных данных. Можно выводить их в ответ в любом порядке (но не нарушая комбинаций вес-стоимость).

### Пример 1

**Ввод:** 
  
6  
10  
3 2 4 1 3 1  
55 80 60 45 105 50  

**Вывод:**

335   
10  
5  
1 3 1 2 3       
50 105 45 80 55     

### Пример 2

**Ввод:**

6  
10  
1 2 3 4 5 6  
10 20 30 40 50 60   

**Вывод:**

100  
10  
4  
4 3 2 1   
40 30 20 10      

### Пример 3

**Ввод:**
  
10  
30  
1 14 18 7 9 9 6 12 19 1   
4 9 4 1 2 10 13 14 10 18   

**Вывод:**

59  
29  
5  
1 12 6 9 1   
18 14 13 10 4  

# Дерево отрезков

## [A. Бизнес](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/SegmentTree/A.cpp)

| Ограничение времени | 2.5 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 128.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Не так давно Дмитрий окончил БИ, разбогател и теперь работает инвестором. Ну, или думает, что работает инвестором. Впрочем, в данной задаче это абсолютно не важно.

Важно лишь то, что у Димы уже куплены $n$ бизнесов, стоимость каждого из которых в течение дня может сильно варьироваться (при этом, возможно даже такое, что один из бизнесов начнет стоить отрицательно).

Чтобы проще работать со стоимостями бизнесов, Дмитрий представил их в виде массива и ввел привычную индексацию с единицы.

Безусловно, иметь такое огромное количество бизнесов очень сложно - во время рабочего дня Дмитрию постоянно приходится участвовать в каких-либо встречах, или решать срочные вопросы, времени следить за ценой бизнесов совсем не остается. Все, что успевает делать Дмитрий в этом направлении - в перерыве между встречами фиксировать в свой ежедневник изменение цены на какой-либо бизнес или же записывать интересующий его отрезок в массиве с ценами, для которого потом нужно будет посчитать сумму.

Таким образом к концу дня в ежедневнике Дмитрия получилось $q$ записей, вида:
1. = i k *(1≤i≤n,−1000≤k≤1000)*, стоимость *i*−го бизнеса стала равна *k*;
2. ? s f $(1≤s,f≤n)$, необходимо посчитать сумму для всех бизнесов с номерами, начиная от $s$, заканчивая $f$ включительно.

Ваша задача помочь Дмитрию и последовательно вывести ответы на каждый запрос суммы. Для удобства - каждый ответ с новой строки.

## Формат ввода  

В первой строке находятся два целых числа $n$ и $q$ $(1≤n≤10^5,1≤q≤10^5)$ - количество принадлежащих Дмитрию бизнесов и суммарное количество записей в ежедневнике.

В следующей строке дано $n$ чисел $n_1,n_2,...,n_n$ $(−1000≤n_i≤1000)$ - стоимости бизнесов Дмитрия в начале дня.

В следующих $q$ строках заданы записи в ежедневники, вид которых был детально рассмотрен в легенде.

## Формат вывода

Для каждого запроса суммы выведите суммарную стоимость бизнесов с индексами от $s$ до $f$, по одному результату в строке.

### Пример 1

**Ввод:** 
  
3 6  
4 17 2  
= 2 1  
? 1 3  
= 1 100  
? 1 3  
? 1 2  
? 2 3  
  
**Вывод:**

7  
103  
101  
3  
   
### Пример 2

**Ввод:**

3 3  
1 2 3  
? 1 3  
= 3 2  
? 1 3     

**Вывод:**

6  
5     

### Пример 3

**Ввод:**
  
7 8  
1 -10 3 7 1 -3 -4  
? 1 6  
= 3 -7  
= 1 10  
? 3 6  
= 7 2  
? 2 6  
= 7 10  
? 1 1  
 
**Вывод:**

-1  
-2  
-12  
10  

## [C. Количество максимумов на отрезке](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/SegmentTree/C.java)

| Ограничение времени | 2 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 128.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Реализуйте структуру данных для эффективного вычисления значения максимального из нескольких подряд идущих элементов массива, а также количества элементов, равных максимальному на данном отрезке.

## Формат ввода  

В первой строке вводится одно натуральное число $N$ $(1 ≤ N ≤ 100 000)$ —количество чисел в массиве.

Во второй строке вводятся $N$ целых чисел от $1$ до $100 000$ — элементы массива.

В третьей строке вводится одно натуральное число $K$ $(1 ≤ K ≤ 30 000)$ —количество запросов на вычисление максимума.

В следующих $K$ строках вводится по два числа — номера левого и правого элементов отрезка массива (считается, что элементы массива нумеруются с единицы).

## Формат вывода

Для каждого запроса выведите в отдельной строке через пробел значение максимального элемента на указанном отрезке массива и количество максимальных элементов на этом отрезке.

### Пример 1

**Ввод:** 
  
5  
2 2 2 1 5  
2  
2 3  
2 5  
  
**Вывод:**

2 2  
5 1  

## [D. Сережа и скобочки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/SegmentTree/D.java)

| Ограничение времени | 3 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

У Сережи есть скобочная последовательность $s1,  s2,  ...,  sn$, или, другими словами, строка $s$ длины $n$, состоящая из символов «(» и «)».

Сереже нужно ответить на m запросов, каждый из которых характеризуется двумя целыми числами $li$, $ri$ $(1 ≤ li ≤ ri ≤ n)$. Ответом на $i$-ый запрос является длина наибольшей правильной скобочной подпоследовательности последовательности $s_{l_{i}}, s_{l_i + 1}, ..., s_{r_i}$. Помогите Сереже ответить на все запросы.

## Формат ввода  

Первая строка содержит последовательность символов без пробелов $s1,  s2,  ...,  sn$ $(1 ≤ n ≤ 10^6)$. Каждый символ это либо «(», либо «)». Вторая строка содержит целое число $m$ $(1 ≤ m ≤ 10^5)$ количество запросов. Каждая из следующих $m$ строк содержит пару целых чисел. В $i$-ой строке записаны числа $l_i$, $r_i$ $(1 ≤ l_i ≤ r_i ≤ n)$ — описание $i$-го запроса.

## Формат вывода

Выведите ответ на каждый запрос в отдельной строке.

### Пример 1

**Ввод:** 
  
())(())(())(  
7  
1 1  
2 3  
1 2  
1 12  
8 12  
5 11  
2 10  
  
**Вывод:**

0  
0  
2  
10  
4  
6  
6  

# НОП и НВП

## [A. НОП](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/LISandLSC/A.java)

| Ограничение времени | 3 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Подпоследовательность – это список элементов, в которых играет роль их порядок. Определенный элемент может появляться в подпоследовательности несколько раз. Подпоследовательностью $z$ строки $x$ является строка $x$, возможно, с удаленными элементами. Например, строка ABC имеет $8$ подпоследовательностей ABC, AB, AC, BC, A, B, C и пустая строка $x$ и $y$ являются строками, то $z$ является общей подпоследовательностью $x$ и $y$, если она является подпоследовательностью обеих строк. Понятия "подпоследовательность" и "подстрока" не эквивалентны. Подстрока – это подпоследовательность, в которой все символы выбраны из смежных позиций в строке.

**Задача:** Для двух заданных строк 
$x$ и $y$ найти длину наибольшей общей подпоследовательности строк $x$ и $y$.

## Формат ввода  

Две строки входных данных содержат в себе значения строк $x$ $(0≤∣x∣≤4000)$ и $y$ $(0≤∣y∣≤4000)$.

## Формат вывода

Целое число – длина наибольшей общей подпоследовательности строк $x$ и $y$.

### Пример 1

**Ввод:** 
  
ABRA  
CADABRA  
  
**Вывод:**

4

### Пример 2

**Ввод:** 
  
ASSIST  
TSSS  
  
**Вывод:**

3

## [B. НОП с восстановлением ответа](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/LISandLSC/B.java)

| Ограничение времени | 3 секунды       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Даны две последовательности, требуется найти и вывести их наибольшую общую подпоследовательность.

## Формат ввода  

В первой строке входных данных содержится число $N$-длина первой последовательности $(1≤N≤700)$. Во второй строке заданы члены первой последовательности (через пробел) – целые числа, не превосходящие 10000 по модулю.

В третьей строке записано число $M$ – длина второй последовательности $(1≤M≤700)$. В четвертой строке задаются члены второй последовательности (через пробел) – целые числа, не превосходящие 10000 по модулю.

## Формат вывода

Требуется вывести наибольшую общую подпоследовательность данных последовательностей, через пробел.

### Пример 1

**Ввод:** 
  
3  
1 2 3   
3  
2 3 1   
  
**Вывод:**

2 3

## [С. Дима и ставки](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/LISandLSC/C.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 64.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

Дима очень любит делать ставки. Он каждый день ставит деньги, и, соответственно, либо выигрывает, либо проигрывает. Дима хочет найти наибольшую подпоследовательность дней, когда он выигрывал больше или проигрывал меньше, чем в предыдущий день подпоследовательности, а также узнать, какие суммы он выигрывал/проигрывал в эти дни

## Формат ввода  

В первой строке входных данных задано число N - количество дней, которые Дима делал ставки (1 ≤ N ≤ 1000). Во второй строке задаются суммы, которые Дима выигрывал или проигрывал (если число положительное, значит выиграл, если отрицательное - проиграл, разделитель - пробел). Суммы выигрышей/проигрышей - целые числа, не превосходящие 10000 по модулю.

## Формат вывода

Требуется вывести наибольшую последовательность, где с каждым днем Дима проигрывает все меньше или выигрывает все больше. Если таких подпоследовательностей несколько, то выведите ту, первый элемент которой встречается в исходном массиве раньше.

### Пример 1

**Ввод:** 
  
5  
-49 -38 26 0 47  
  
**Вывод:**

-49 -38 26 47

### Пример 2

**Ввод:** 
  
5  
12 17 -3 37 -17  
  
**Вывод:**

12 17 37

### Пример 3

**Ввод:** 
  
5  
2 -10 34 -5 -6  
  
**Вывод:**

2 34

## [D. Эрен Ега](https://github.com/mishcum/Algorithms-and-data-structures/blob/main/LISandLSC/D.java)

| Ограничение времени | 1 секунда       |
|---------------------|-----------------|
| Ограничение памяти  | 256.0 МБ         |
| Ввод                | стандартный ввод|
| Вывод               | стандартный вывод|

В древнем королевстве Нумерландия жил король Эрен Ега, известный своей мудростью и любовью к математическим головоломкам. В его библиотеке хранился древний манускрипт, в котором содержалась тайна создания волшебной числовой последовательности. Эта последовательность, как говорили легенды, могла открыть двери к несметным сокровищам.

Однажды король объявил конкурс среди своих подданных: тот, кто разгадает тайну манускрипта и найдёт наибольшую возрастающую подпоследовательность, получит звание Главного Мудреца и будет щедро награждён.

Манускрипт гласил:

1. "Начни с магического числа a, известного только тебе."
2. "Для каждого следующего числа в последовательности следуй древнему заклинанию: возьми текущее число, умножь его на секретный ключ, добавь загадочное число и после этих операций возьми остаток от деления на великое число. Эти ключи скрыты в символах древнего языка."

Король Эрен дал участникам числа: k - секретный ключ, b - загадочное число, и m - великое число. Найдите наибольшую возрастающую подпоследовательность в этой последовательности из n чисел!

## Формат ввода  

Программа получает на вход пять целых чисел:
1. Длина последовательности $n$ $(1≤n≤10^6)$,
2. Начальный элемент последовательности **a**
3. Параметры **k**, **b**, **m** для вычисления последующих членов последовательности $(1≤m≤10^4,0≤k<m,0≤b<m,0≤a<m)$.

## Формат вывода

Необходимо найти и вывести наибольшую возрастающую подпоследовательность из данной числовой последовательности, разделив числа пробелами. Если существует несколько таких подпоследовательностей, выведите любую из них.

### Пример 1

**Ввод:** 
  
19 10 14 12 22
  
**Вывод:**

6 8 10 14 20

### Пример 2

**Ввод:** 
  
18 4 6 4 15  
  
**Вывод:**

1 4 7 10 13

### Пример 3

**Ввод:** 
  
5 6 5 6 9
  
**Вывод:**

0 6

# Строки

